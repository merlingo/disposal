import { createSlice } from '@reduxjs/toolkit';
import {authHeader} from '../pages/login';

export const slice = createSlice({
  name: 'alarm',
  initialState: {
    alarm_loading:true,
    option_loading:true,
    alarms: [{"id":"1","name":"xxx","rule":"yyy"}],
    vendors:[],
    products:[],
    vuls:[],
    selectedVuls:[],
    options:[],
    last_alarm:{},
    is_last_alarm:false,
  },
  reducers: {
    save_option:{
      reducer: (state) => {
          // Redux Toolkit allows us to write "mutating" logic in reducers. It
          // doesn't actually mutate the state because it uses the immer library,
          // which detects changes to a "draft state" and produces a brand new
          // immutable state based off those changes
          state.loading = true;
          //state.products=action.payload.email;

          console.log("reducers vulnerability load reducer:");
        },
      prepare: (cid, option) =>{
          console.log("action save_option save_product prepare:"+cid);
          return {
              payload:{
                  request: {
                      url: "/webapi/alarm/option/"+cid,
                      method: 'POST',
                      headers: authHeader() ,
                      data: option,
                    }
              }
          }
      }
  } ,
  save_option_SUCCESS: (state,action) => {
    state.options = [...state.options,action.payload.data];
    state.option_loading=false;
    console.log("reducers save_option save_product_SUCCESS:"+JSON.stringify(state.options));

  },
  save_option_FAIL: (state, action) => {
    state.value = action.payload;
    console.log("reducers save_option save_product_FAILURE:");

  },
    load_alarms:{
      reducer: (state) => {
          // Redux Toolkit allows us to write "mutating" logic in reducers. It
          // doesn't actually mutate the state because it uses the immer library,
          // which detects changes to a "draft state" and produces a brand new
          // immutable state based off those changes
          state.loading = true;
          //state.products=action.payload.email;
  
          console.log("reducers vulnerability load reducer:");
        },
      prepare: () =>{
          console.log("action vulnerability load prepare:");
          return {
              payload:{
                  request: {
                      url: "/webapi/alarm/",
                      headers: authHeader() ,
  
                      method: 'GET',
                    }
              }
          }
      }
  } ,
  load_alarms_SUCCESS: (state,action) => {
    state.alarms = action.payload.data;
    state.loading=false;
    console.log("reducers load_alarms_SUCCESS load_SUCCESS:"+JSON.stringify(state.alarms));
  
  },
  load_alarms_FAIL: (state, action) => {
    state.value = action.payload;
    console.log("reducers load_alarms_FAIL load_FAILURE:");
  
  },
    load_options:{
      reducer: (state) => {
          // Redux Toolkit allows us to write "mutating" logic in reducers. It
          // doesn't actually mutate the state because it uses the immer library,
          // which detects changes to a "draft state" and produces a brand new
          // immutable state based off those changes
          state.loading = true;
          //state.products=action.payload.email;
  
          console.log("reducers load_options load reducer:");
        },
      prepare: () =>{
          console.log("action load_options load prepare:");
          return {
              payload:{
                  request: {
                      url: "/webapi/alarm/options/",
                      headers: authHeader() ,
  
                      method: 'GET',
                    }
              }
          }
      }
  } ,
  load_options_SUCCESS: (state,action) => {
    state.options = action.payload.data;
    state.loading=false;
    console.log("reducers load_options load_SUCCESS:"+JSON.stringify(state.products));
  
  },
  load_options_FAIL: (state, action) => {
    state.value = action.payload;
    console.log("reducers load_options load_FAILURE:");
  
  },
  last_alarm:{
      reducer: (state) => {
          // Redux Toolkit allows us to write "mutating" logic in reducers. It
          // doesn't actually mutate the state because it uses the immer library,
          // which detects changes to a "draft state" and produces a brand new
          // immutable state based off those changes
          state.loading = true;
          //state.products=action.payload.email;
  
          console.log("reducers last_alarm load reducer:");
        },
      prepare: () =>{
          console.log("action last_alarm load prepare:");
          return {
              payload:{
                  request: {
                      url: "/webapi/alarm/last/",
                      headers: authHeader() ,
  
                      method: 'GET',
                    }
              }
          }
      }
  } ,
  last_alarm_SUCCESS: (state,action) => {
    state.is_last_alarm = action.payload.data.islast;
    state.last_alarm = action.payload.data.alarm;

    state.loading=false;
    console.log("reducers last_alarm last_alarm_SUCCESS:"+JSON.stringify(state.alarm));
  
  },
  last_alarm_FAIL: (state, action) => {
    state.is_last_alarm = false;
    console.log("reducers last_alarm last_alarm_FAIL:");
  
  },
}
});

export const { save_option, save_option_SUCCESS,save_option_FAIL, load_alarms, load_alarms_FAIL,load_alarms_SUCCESS, load_options, load_options_SUCCESS, load_options_FAIL,
last_alarm,last_alarm_FAIL,last_alarm_SUCCESS,} = slice.actions;



export default slice.reducer;
